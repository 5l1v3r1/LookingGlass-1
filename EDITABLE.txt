These are details on how editable fields currently work and are subject to
change. I suggest running this LookingGlass branch with the latest version of
DocManager.

# Edit Flag

In config/initializers/editable, there is an environment variable called
WRITEABLE that must be set to true for editing to work. It is already set in
this branch, but should not be normally set.


# The Frontend

When any page is loaded, app/helpers/data_fields/display_type_switcher.rb
renders the partials needed to display the fields on that page. Normally, it
only displays fields that are not blank. I added a display_field? method which
displays fields if either of the following conditions are true-
1. It is not blank
2. ENV['WRITEABLE'] == true AND it is loading on a show page (this is in an
is_editable? method used in a couple places)

I then removed the data.blank? checks from the partials as they are no longer
needed and were redundant to have so many in the first place when partial
rendering is controlled by the central type_switcher method anyways.

So this enables blank fields showing up when editing is enabled. I also
created a method, set_editable_class, in the same helper. This passes the
class "editable " to the partial rendered. This is saved in the variable
editclass. Currently, I am passing it to all partials in type_switcher, but we
can pass it to only some once we know which need it.

While passed to all field partials, the editclass variable is only actually
used in show_text, where I replaced the hardcoded editable css class with the
following-
<span class="<%= editclass %> type-text">
   <%= raw(format_text(text)) %>
</span>


## Changing Partials Rendered for Field Type on Show View

The editclass variable can be used on other field types similarly. That covers
a lot though as most fields are displayed as text on the show view. But you
may want to change this in some cases. If you want to render a partial other
than show_text for a certain field type, say a date field, you need to make
the following changes-

1. Create a new partial in app/views/docs/field/ that displays the field how
you choose. Perhaps _show_date.html.erb or similar. 


2. In app/helpers/data_fields/display_type_switcher.rb, in the
update_type_for_action method on line 18 add the name of the type to the
nonstandard_show_types array. Looks like you already added Date.


3. There are different versions of the next step depending of if the field
already exists and where the views should differ-
If it is a new field: Add a new when statement to the case statement in
type_switcher (also in the display_type_switcher.rb helper). This should
include a call to render the partial and pass any variables used in the
partial. Most follow a similar format and can be adapted. In this case, you
also will need to add the following to any views where this field type should
be displayed-
<%= show_by_type("New Field Name", doc, @dataspec, "show") %>
(see app/views/docs/show/tabs/panes/text_partials/_text_fields.html.erb for
more examples)

If it is an existing field that should be handled differently in show vs
index: After the changes above, the switch statement should go to the "Date"
case (or whichever is the case for the field). If a field should be handled
differently in index and show, an if statement or other conditional checking
the action may be needed to render different partials for different
actions. For example-
if action == "index"
   render partial: "docs/fields/date", locals: { date: field_data, human_readable: human_readable_name, editclass: editclass }
elsif action == "show"
   render partial: "docs/fields/show_date", locals: { date: field_data, human_readable: human_readable_name, editclass: editclass }
	
If it is an existing field that should NOT be handled differently in show vs
index: You don't need to do anything else except change the partial as needed
for whatever type display changes you are adding.



# The Backend

When editor.js detects that a field was modified, it saves the new text in
saved_content and marks edited as true in the dictionary entry for that
field. Then, when the fields are saved, it posts the whole edited dictionary
to the edit_document action in the document controller as follows-
$.post( "/edit_document", { edited: editable} );

This controller does the following-
1. Gets the original document and associated data (document class, index name,
etc.)

2. Makes a list of fields that were marked changed in the edited hash and
merges them with the original document. It just replaces the fields with the
changed ones.

So for arrays and other specialized fields, if possible the full array (old
and new items) should be returned in the same format the view was passed. If
this is not possible, the array can be handled in a specialized way that does
additional parsing- just let me know.

3. Sends the document to doc_manager for indexing. This will save the new item
and it will be available upon refresh. We should figure out how to handle
refreshes more smoothly.

A note on change tracking: doc_manager saves the new version in the version
list, so there is a full change history for each document. However, this is
not visible by default. To see changes, the fields need to be added to the
fields_to_track array in the version_tracking_details section of the
dataspec. If one of these fields is edited, that will cause the document to be
marked as changed and the change tracker view to showe.

However, I think for the hosted archiving service initially it is fine to have
this array be empty. Long term perhaps we can redo the change tracking view
and have a menu with versions (so people can see more than two) and some way
to choose for what fields this is enabled. But the data is there in case
rollbacks to earlier versions are needed.
